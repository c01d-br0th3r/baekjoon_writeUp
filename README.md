# 백준 알고리즘 라이트업 저장소

### 카카오 / 우아한형제들 코테 보고 현타와서 만들었습니다.

백준 계정 새로 팜: **c01d_br0th3r**<br />
목표: 지금까지 스터디한 문제들 싹 다 다시 풀고 구종만 알고리즘 부시기


## Day 1

* [BOJ 2231](https://www.acmicpc.net/problem/2231) **분해합**

쉬운 완전탐색 문제.<br />
원래의 수에 자릿수를 쪼개 더해가며 입력값을 만들 수 있는지 확인하면 된다.<br />
`ret`이 전역변수이기 때문에 만들 수 없는 경우 0으로 유지되는 것이 포인트!<br />

* [BOJ 7568](https://www.acmicpc.net/problem/7568) **덩치**

정렬만 잘 해준 후 그대로 뽑아주면 끝!!<br />
이를 위해 `vector`로 인풋을 저장하고 `sort` 함수를 사용했다.<br />
한 번 틀렸는데, 문제를 대충 읽어서 키와 몸무게가 같은 경우 예외를 안 주었다. 문제를 잘 읽자..<br />

* [BOJ 1620](https://www.acmicpc.net/problem/1620) **나는야 포켓몬 마스터 이다솜**

처음 풀었을 때에도 시간초과가 났었는데, 이번에도 그랬다..<br />
퀴즈로 숫자가 나왔을 경우엔 O(1)로 탐색이 가능하지만 문자열을 받았을 경우 O(n^2)이 된다!! => 시간초과..<br />
STL의 `map`을 사용하면 `String: int`의 형태로, JS의 객체처럼 쓸 수 있다는 것을 알았다.<br />
따라서 `map`으로 문자열이 들어왔을 시 출력할 정수를 저장하고, 다른 string 배열에서 숫자가 들어왔을 시 문자열을 출력하도록 하면<br />
O(1) 시간에 탐색이 가능하다.<br />

***************************************************************************

## Day 2

* [BOJ 1436](https://www.acmicpc.net/problem/1436) **영화감독 숌**

범위가 적당하고 시간도 충분하니 브루트포스하면 된다.<br />
첫 번째 풀이는 나머지 연산자를 통해 연속된 6이 3개이면 카운트를 올리는 방식으로 전부 찾았고,<br />
두 번째 풀이는 C++의 `string`과 `find` 함수를 이용해서 구헀다.<br />
실행 시간을 비교해봤는데 전자가 6배정도 빨랐다.. 알아두자!!

* [BOJ 2805](https://www.acmicpc.net/problem/2805) **나무 자르기**

처음 풀었을 때에도 시간초과가 발생했던 기억이 있는 문제.<br />
이번에도 역시 시간초과였다. 이분탐색을 구현할 때 `mid+1`이나 `mid-1`값으로 바꿔줘야 하는데 계속 현재값+1로 한다..<br />
관련 문제들을 풀어보며 확실하게 익히고 넘어가야 할 것 같다ㅠㅠ

* [BOJ 1260](https://www.acmicpc.net/problem/1260) **DFS와 BFS**

DFS, BFS 알고리즘을 처음 접한 것이 벌써 작년이다!!<br />
그 땐 `Queue` 라는 자료구조도 뭔지 모른 채 C언어로 함수 하나하나 작성해가며 구현했던 아픈 기억이 있다..<br />
C++의 STL 사용법을 익히니 재귀를 이용하는 DFS보다 BFS가 쉽고 가볍게 느껴진다🙂

***************************************************************************

## Day 3

* [BOJ 15354](https://www.acmicpc.net/problem/15354) **Aron**


* [BOJ 15355](https://www.acmicpc.net/problem/15355) **Programiranje**


* [BOJ 12761](https://www.acmicpc.net/problem/12761) **돌다리**

(또) 문제를 안 읽어서 1시간가량 삽질한 문제.<br />
문제도 정말 단순하고, 주미에게 도달하지 못하는 경우도 없고, 범위도 적당 + 시간도 충분하기 때문에 BFS로 완전탐색 해주면 된다.<br />
DFS를 사용하지 않은 이유는 8가지나 되는 이동방법 중 하나만 파서 끝까지 가는 것이 너무나도 비효율적이기 때문!!<br />
이 쉬운 문제를.. 문제 첫 줄에 `돌의 번호는 0 부터 100,000 까지 존재하고` 란 조건을 안읽어서 실컷 삽질했다..<br />
당연히 인덱스를 넘어갈 수 있다고 생각해서 범위를 최댓값인 `30 * 100000`으로 잡아버렸다.<br />
십만을 넘어서는 범위를 설정할 시 답보다 더 작은 경우의 수가 나올 수 있는 것 같다.<br />
카카오 코테에서도 문제 안 읽어서 신나게 삽질했는데ㅠㅠㅠ 문제 읽자, 또 읽자 제발 읽자ㅠ

***************************************************************************

## Day 4

* [BOJ 9012](https://www.acmicpc.net/problem/9012) **괄호**

스택을 처음 배울 때 무조건 응용문제로 나오는 괄호 문제.<br />
`(`가 들어오면 `push`, `)`가 들어오면 `pop` 해주고, 스택이 비어있는데 `pop`을 시도하거나 반복문이 끝나도 스택이 비어있지 않으면<br />
완벽한 괄호라고 할 수 없다. 따라서 `flag`를 설정해서 분기를 나눠주면 끝나는 간단한 문제이다.<br />
이것도 처음 풀 땐 스택을 하나하나 구현했는데, 이번엔 STL을 사용해서 풀었다!!

* [BOJ 14501](https://www.acmicpc.net/problem/14501) **퇴사**
* [BOJ 1987](https://www.acmicpc.net/problem/1987) **알파벳**

***************************************************************************
